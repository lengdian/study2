java提供的四种引用类型：从JDK1.2版本开始，把对象的引用分为4种级别，从而使程序能更加灵活地控制对象的生命周期。这4种级别由高到低依次为：强引用、软引用、弱引用和虚引用。

    强引用:
        强引用不会被GC(垃圾回收器：garbage collections)回收，并且在java.lang.ref里也没有实际的对应类型，平时工作接触的最多的就是强引用。
        Object obj = new Object();这里的obj引用便是一个强引用。
        如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。
        当内存空间不足时，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

    软引用(SoftReference)：
        如果一个对象只具有软引用，则当内存空间充足时，垃圾回收器就不会回收该对象；当内存空间不足时，就会回收这些对象的内存。
        只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存（参考引用网址1实例）。
        软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被gc回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

    弱引用(WeakReference):
        如果一个对象只具有弱引用，只要gc线程在自己的内存空间中检测到了，该对象就会立即被回收，对应内存也会被释放掉。
        相比软引用，弱引用的生命周期要短很多。
        不过因为gc线程是一个优先级很低的线程，也不一定很快就会释放掉弱引用的内存。
        WeakHashMap与弱引用有关。

    虚引用(PhantomReference)：
        "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。
        如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。
        虚引用主要用来跟踪对象被垃圾回收的活动。
        虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列(ReferenceQueue)联合使用。
        当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
            程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
            程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。



參考網址：
1、http://www.2cto.com/kf/201207/139522.html
2、http://www.iteye.com/topic/401478